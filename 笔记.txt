1. 复习与反馈
  -> 随机数的问题
    var str=" ";  // '210 '
    for(var i=0;i<10;i++){
        var s=str.charAt(Math.floor(Math.random()*( str.length )))
        str=str.replace(s,i+s)
    }
    str=str.replace(" ","")
    console.log(str)

    百度给出的答案
    var arr = [ 0,1,2,3,4,5,6,7,8,9 ];
    for ( var i = 0; i < arr.length; i++ ) {
      var index = Math.floor( Math.random() * 10 );
      if ( i != index ) {
        var tmp = arr[ i ];
        arr[ i ] = arr[ index ];
        arr[ index ] = tmp;
      }
    }

  -> 构造函数Foo的原型属性Foo.prototype的__proto__属性指向的是Object.prototype(它构造函数的原型属性)
    也就是说Foo.prototype 是 Object实例化而来的？
    或者说所有对象的__proto__属性都指向它构造函数的原型属性，它的原型对象？
    只要有__proto__属性，就有它的构造函数？  除了Object.prototype?

    在 js 语言规范中, 并没有说明 原型实例是 Object 创建出来的.
    我们是根据推测得知是 Object 创建出来. 

  -> 多态的应用
    考虑百度: 将子类对象赋值给父类对象, 使得不同子类对象有不同的具体实现方式, 让父类统一调用.
    我们不要扣概念, 考虑多态在实现形式上是如何操作.
    所谓的多态就是多种状态, 即同一个变量调用同一个方法, 会有不同的结果.
      如果要使用代码来实现: 
      1> 约定方法名 
      2> 代码编写的时候使用的是一个特殊的对象. 里面有方法, 但是没有具体行为
      3> 要使用各种对象来实现方法
      4> 将对象赋值给编码时用的变量   
    假设场景: 演讲( speak )
      约定每一个对象应该具有 speak 行为
      编写代码的时候使用 
        var content = {
          speak: function () {}
        };
      这段代码, 函数体什么都没有, 但是这样在开发的过程中不会因为该对象没有装配而出现错误.
        content.speak();
      约定不同的对象要实现该具体的行为
        var study = {
          speak: function () {
            console.log( '让我们好好学习吧...' );
          }
        };
        var worker = {
          speak: function () {
            console.log( '建设祖国大好河山 ... ' );
          }
        };
        var master = {
          speak: function () {
            console.log( '同志们辛苦了, 同志们晒黑了 ...' );
          }
        };
      
    现代编程中的各种设计模式都建立在多态的基础之上.
  -> 利用 Function 创建 DOM
    var str = 'document.createElement( "div" )';
    var dom = (new Function ( 'return ' + str ))();


2. 块级作用域
  -> JavaScript 今天的发展趋势
    编程语言有一个变化阶段( 不是很完整 ):
      1> 机器语言阶段, 利用机器语言控制芯片针脚什么时候出现低电平什么时候出现高电平.
          这个阶段的语言常常以汇编语言做代表.
      2> 高级语言阶段, 使用自然形式的语言来进行编码. 代表 C 语言. 
          C 系的编程语言都可以直译成自然语言
          例如: if ( func instanceof Function ) { func(); }
          自然语言, 计算机不认识. 引入编译器. 它就相当于翻译器. 
          编译器将 你写的 C 代码翻译成 计算机可以认识的 二进制数据.
      3> 解释型语言, 也使用 C 系的编程语法, 以 JavaScript 为代表.
          计算机也不认识这样的编程语言, 需要解释器. 还是相当于翻译.
          把语言代码翻译成计算机可以认识的代码, 执行.
      形容:
        编译器, 相当于书面翻译. 有很多词法句法的讲究, 有更多的意译.
        解释器, 相当于同声传译. 语句是一边解释一边执行. 几乎会按照你的思路一步一步执行, 不会过多优化.
  -> JS 的发展趋势
    JS 都知道是解释型语言. 浏览器的发展已经阻碍到语言的发展了.
    今天 js 运行平台已经不再局限于 浏览器了. 还有 node 平台.
    随着大型网站的开发, js 的语法特性( 不支持模块化, 没有作用域限制, 不能大规模开发, ... )在不断被新增.
    所以程序发明了编译器, 将高级的 js 语法特性编译成 IE 级别的浏览器可以识别的 js 代码. 

    也就是, 语言不断的在发展, 出现很多高级的性能与特性, 但是同时配合的高级的编译器将其转换成低级的语法实现.

    在这些语法特性中极具代表的除了 ES6 以外, 再就是 微软的 TypeScript, 以及 Facebook 的 flow.js

    极具代表的就是类的写法, 类就是一个模板, 用于构造对象的模板. 我们要创建一个 Person, 我们约定要有 
    name, age, gender, 和 sayHello 的方法.

    用 TS 怎么写:

      class Person {

        public name: string;
        public age: number;
        public gender: string;

        constructor( name: string, age: number, gender: string ) {
          this.name = name;
          this.age = age;
          this.gender = gender;
        }

        public sayHello () {
          console.log( '你好, 我是 ' + this.name );
        }

      }  

    TS的中文网: http://www.tslang.cn/
    阮一峰ES6: http://es6.ruanyifeng.com/
  -> 块级作用域
    ES5 以前是不支持 块级作用域的, 只支持词法作用域.
    什么是作用域: 所谓的作用域就是说 标识符 从哪个位置可以被访问到, 到哪个位置不能被访问到.
    块级作用域是说, 使用代码块来限定标志的使用范围. 在 ES6 中引入 let 关键字, 来声明块级作用域的变量.
    使用的时候 let 与 var 的用法相同.

    块级作用域的访问范围: 从变量的声明开始到变量所在的 最近的 花括号( { } ) 结束.

3. 词法作用域
  -> 词法作用域与块级作用域不同, 在 js 中词法作用域的变量在当前作用域中具有全局可访问性.
  -> js 执行原理
    -> js 执行分成两个阶段: 预解析, 解释执行
      在预解析阶段, js 引擎做基本的语法分析, 和记录声明数据
      解释执行主要是对代码的解析然后一步步执行代码
    -> 什么是声明: 原意是说声明时告诉编译器( 解释器 )已存在什么标识符
      在 js 中声明有两种, 一种是变量的声明, 另一种是函数的声明.
      变量的声明严格的语法: var 变量名
        注意: 
          平时写的 var num = 123; // 语法糖
          实际上这句话在解析的时候会分成两句
            var num;
            num = 123;
      函数的声明( 难点 ): 
        出现在独立的代码结构中, 以 
          function 函数名( 参数列表 ) { 
            函数体 
          } 
        的形式编写的代码为函数声明. 
        
        注意:
          var func = function () {};   // 函数表达式

          !function() {}               // 函数表达式

          // 特例
          if ( true ) {
            function foo() {
              console.log( 123 );
            }
          } else {
            function foo() {
              console.log( 123 );
            }
          }


          function foo() {
            function func() {

            }
          }

    -> 补充概念
      由数据与运算符组合起来 有结果 的代码结构称为表达式.
      问题:
        1, true, 'abc', 常量表达式
        1 + 2,  算术表达式
        !true,  逻辑表达式
        num = 123, 赋值表达式
        1,2,3   逗号表达式, num = ( 1, 2, 3, 4 + 5, 6 + 7 )
        func()  函数调用表达式
        ...
  -> js 预解析到底完成了什么
      在 js 预解析的时候, 可以想象一下, 在 js 引擎中有一个对象, 是用于存储名字用的.
      js 的代码从上往下进行预解析, 凡是发现变量的声明, 就会在该对象中存储下 变量名, 
      并且其值为 undefined. 犹如: 
          internal = {
            变量名: undefined
          }
      在 js 中允许重复声明, 凡是发现重复声明, 其后的重复声明无效. 即:
          var num = 123;
          var num = 'abc'
        等价于
          var num = 123;
          num = 'abc';
      其实说白了就是凡是看到声明, 会先到内部的那个对象中看看有没有记录下这个名字, 
      如果记录下了就忽略. 如果没有记录下就记录下来.

      如果发现了函数的声明, 要做两件事. 第一件事将函数的名字记录在这个内部对象中. 
      注意, 如果函数名与变量名重名, 将变量名当做重复声明看待. 即名字忽略不管. 注意第二步还是要做.
      在发现函数声明后的第二件事儿就是将函数体与名字联系起来.
        犹如:
          function foo( ) {
            console.log( '123' );
          }
        在内部代码中那个对象里
          internal = {
            foo: function foo () {
              console.log( '123' );
            }
          }
      以上操作即为预解析的时候, 记录变量声明的结果.

  -> 实操案例:
    
    if ( 'a' in window ) {
      var a = 123;
    }
    console.log( a );

    1> 预解析, 从上往下找到 a, 它是声明, 所以记录下来
    2> 预解析结束, 开始执行代码
      1) 执行的第一句话是 if 中的表达式 'a' in window 为真
      2) 进入 if 函数体, 为其赋值, a 存储 123
      3) 结束 if 结构, 打印 a 的值为 123


4. 代码分析
  -> 目的是分析清楚代码每一句话的执行过程与结果. 目的在于学会分析代码的执行原理以及分析面试题.
  -> 分析步骤
    1> js 代码在预解析的时候会做两件事情, 一个是语法, 另一个是记录声明( 不包括函数内的声明 )
    2> 预解析完成后会从第一行代码开始依次执行 js 代码( 语句 )
    3> 如果进入了函数, 会在函数进入, 执行之前, 对函数内再进行对应的预解析
    4> 如果函数内预解析结束, 再从函数开始的位置一步一步的执行代码.

    注意: 就是每一个变量和每一个数据的变化.


5. 变量访问规则( 变量搜索原则 )
  考虑到预解析的范围, 只有函数可以阻碍其解析. 那么实际上在 js 中唯有函数可以限制变量的作用域.
  在 词法作用域中我们描述到, 变量在当前执行环境中具有全局可访问的性. 是因为预解析带来的.

  -> 作用域的划分( 作用域链 )
    我们可以将作用域链看成一个数据序列, 变量对象等数据就在这个数据序列中.
    要明确变量的作用域划分就需要分清楚这个序列是怎么出现的.

    操作步骤:
    1> 将所有的 script 标签看成一个 0 级作用域. 可以考虑绘制一条直线. 上面标记为 0 级.
    2> 在全局作用域中, 凡是看到声明, 名字等就在线上标记一个举行块, 里面放置需要的名字( 不要数据的值 )
    3> 0 级链绘制完, 分析 0 级作用域中所有的函数, 凡是函数, 引出 1 级链, 依旧绘制直线.
    4> 分别在函数中检查是否有声明, 如果有绘制到对应的链中, 如此往复, 得到新的链, 每一条先都比原来的数字 +1.
    5> 绘制完成后, 即得到作用域链 结构
  
  -> 变量搜索原则
    凡是需要访问变量, 会考虑在当前作用域中查找是否含有该变量的声明. 如果没有对应的声明, 会到上一级作用域链中
    查找是否有对应的声明. 如果有直接使用, 结束查找. 如果没有继续到上一级作用域中. 知道 0 级作用域. 如果还没有
    就会抛出一个错误, 就是 is not defined.
  
  -> 实例
    var num = 123;
    function func1() {
      var num = 456;
      function func2() {
        var num = 789;
        function func3() {
          console.log( num );
        }
        func3();
      }
      func2();
    }
    func1();

    变式:
    var num = 123;
    function func1() {
      num = 456;
      function func2() {
        var num = 789;
        function func3() {
          console.log( num );
          var num = 'abc';
        }
        func3();
        console.log( num );
      }
      func2();
      console.log( num );
    }
    func1();

6. ( 了解 )在函数声明中的一些争议问题
  -> 代表: 你不知到的 javascript 上
    根据我们队函数的理解, 只要函数不在代码结构中, 那么函数就应该是声明, 而非表达式.
      if ( true ) {
        function foo() {
          console.log( true );
        }
      } else {
        function foo() {
          console.log( false );
        }
      }

      foo(); // false

    但是, 我们发现在火狐浏览器, 以及今天的谷歌浏览器中, 我们的预解析似乎会根据 if 中的判断进行预解析.

    大胆的做一些猜测. 此时 foo 应该是转换成了表达式, 而非声明. 但是它也不是表达式.

    注意: 函数作为表达式, 函数的名字应该只允许在内部访问.
      var func = function foo() {
        // foo 即为函数的名字 只允许在函数内部访问
        console.log( foo );
      }

    我们只能认为在预解析的过程中, if 起作用了.



7. 垃圾回收( GC )
  -> 程序运行一定会涉及到内存的申请与释放
    早期的 C 语言( C++ )都手动的控制内存的申请与释放.
    在计算机中的内存不是一个固定, 属于 "流动型" 内存( 例如 公交车的座位 ).
    内存的管理决定了程序的运行效率. 
    内存如果是连续的, 程序的运行效率高, 内存如果出现很多碎片, 程序运行的性能就低.
    什么情况下会出现碎片呢? 
  -> js 中凡是涉及到对象的时候 就会申请内存.
    创建对象, 调用函数, 等操作都会涉及到申请内存. 但是函数的内存由系统进行管理. 一旦调用结束内存回收.
    但是对象的内存由 js 引擎进行管理. js 中对象具有动态特性. 
    所以 js 引擎都会带有垃圾回收机制. 垃圾回收做两件事儿, 一个是释放不使用的内存, 二是整合内存.
    结论, 进行垃圾回收的时候, 会影响程序的性能.
  -> js 怎么进行回收, 什么时候进行回收呢?
    注意: 借用高程里面的一句话, 你只需要记住 js 一定会回收, 你相信它即可. 
    在 js 中凡是不使用的对象才会被回收. 
      var o = {};
    在代码运行的过程中, 假设浏览器不关闭. 那么 这个对象( 右边的那个 ) 就不会被回收.
    如果代码运行了这么一句话: 
      o = null;
    那么这个对象就不再被引用着( 如果没有任何变量指向它 ), 这个对象就可以被回收.
    但是如果在 o = null 之前执行了一句话 var obj = o. 那么 o 不再指向这个对象,
    但是 obj 指向了这个对象, 即它不是 "幽灵". 这个对象依旧不会被回收.

8. 常见的垃圾回收算法
  垃圾回收算法需要弄明白的问题有两个, 一个是回收什么内存, 二是什么时候回收
  -> 如何标记内存
    1> 引用计数法
      凡是对象, 在内存中会引用一个 count 指标, 如果对对象进行引用, 那么 count 就会自动 +1
      例如: 
        new Object(); // 此对象的 count 为 0

        var o1 = new Object(); // 此对象的 count 为 1
        var o2 = o1;  // 该对象的 count 加 1, 变为 2
        o1 = {};      // 这个新对象的 count 为 1, 原来的那个对象为 1
        o2 = null;    // 此时新对象的 count 还是 1, 原来的那个对象就是 0 了, 那么 它就可以释放了.

    2> 标记法
      凡是创建的对象都会获得一个标记, 表示被引用者. 在代码的运行机制中每一个变量会被创建一个索引
      记录在系统的内部. 可以类比城 字典的索引. 

      如果要进行回收, 会遍历所有的变量索引, 对应的去找这个对象在哪里, 如果找到了对应的对象给对象加一个标记.
      如此遍历以后, 我们的所有的对象就含有了对应的标记. 在遍历对象所在的内存, 将没有对应标记的对象找出来,
      表示这个内存可以被回收.
  -> 什么时候回收
    1> 定值域法
      我们在内存的使用过程中会监视每一个对象所占内存, 以及总内存. 会实时的与值域进行比较. 如果当这个数据超过了我们的值域. 那么就会触发垃圾回收.
    2> 动态值域法.
      给定上下限, 同时监视程序的密集度. 
    3> 代的方法


9. 闭包
  闭包, 从字面意义说, 就是封闭的包裹的结构.
  在 js 中什么是闭包的: 就是函数在运行的时候, 构成闭包.
  注意:
    1, 函数定义后, 写在那里. 只是一个普普通通的对象, 不会创建任何的内存, 不会影响到其他的任何东西. 
    2, 只有当函数运行起来, 在函数执行过程中, 结束之前. 函数会构成一个封闭的空间. 
    3, 根据词法作用域, 函数内在访问变量的时候, 如果函数内没有可以在外面来找, 反之不行.
    4, 同时函数也包含了一定的范围.
    5, 结合一下, 此时在函数结束之前, 函数构成了一个封闭的包裹的结构, 此为闭包.

  注意的问题:
    闭包有什么用? 我们如果而已让函数调用之后, 不释放, 此时这个闭包就有作用了.
    函数在执行完以后, 会释放其占用的内存. 函数执行结束后, 如果保留其内存中的访问能力, 该内存就不会被释放.
      function func() {
        var num;
        function foo() {
          connsole.log( num );
        }
        return foo;
      }

      var f = func();






